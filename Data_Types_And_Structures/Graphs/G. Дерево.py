def dfs(a, parent):
    # Обозначаем вершину a как посещенную
    visited[a] = True

    # Итерируемся по всем соседям вершины a
    for b in matrix[a]:
        # Пропускаем родительскую вершину, чтобы избежать ложного обнаружения цикла
        if b != parent:
            # Если сосед b уже посещен, значит, найден цикл
            if visited[b]:
                return True
            # Рекурсивно вызываем dfs для соседа b с a как родитель
            if dfs(b, a):
                return True  # Если цикл найден в поддереве, возвращаем True

    return False  # Возвращаем False, если цикл не найден


# Считываем количество вершин и рёбер в графе
n, m = map(int, input().split())

# Для дерева должно выполняться условие: количество рёбер должно быть на 1 меньше, чем количество вершин
if m != n - 1:
    print("NO")  # Если условие не выполняется, выводим "NO" и завершаем программу
    exit()

# Инициализируем матрицу смежности для хранения графа
matrix = [[] for _ in range(n)]

# Считываем рёбра графа
for _ in range(m):
    a, b = map(int, input().split())
    # Добавляем рёбра в матрицу смежности (граф неориентированный)
    matrix[a - 1].append(b - 1)
    matrix[b - 1].append(a - 1)

# Инициализируем массив для отслеживания посещенных вершин
visited = [False] * n
cycle_found = False  # Флаг для проверки наличия цикла

# Запускаем обход графа по всем вершинам
for i in range(n):
    if not visited[i]:  # Если вершина i не посещена
        # Если найден цикл, устанавливаем флаг и прерываем цикл
        if dfs(i, -1):
            cycle_found = True
            break

if cycle_found:
    print("NO")  # Граф не является деревом, если найден цикл
elif all(visited):
    print("YES")  # Все вершины посещены, граф соединен и без циклов, значит, это дерево
else:
    print("NO")  # Если не все вершины посещены, значит, граф не соединен
