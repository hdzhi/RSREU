def dfs(v):
    # Обозначаем вершину v как посещенную
    visited[v] = True
    # Создаем список для хранения текущей компоненты связности и добавляем в него вершину v
    comp = [v]
    # Инициализируем стек с начальной вершиной
    stack = [v]

    # Пока стек не пуст
    while stack:
        # Извлекаем вершину из стека
        curr = stack.pop()
        # Проходим по всем соседям текущей вершины
        for u in graph[curr]:
            # Если соседняя вершина еще не посещена
            if not visited[u]:
                # Помечаем ее как посещенную
                visited[u] = True
                # Добавляем в текущую компоненту
                comp.append(u)
                # И добавляем в стек для дальнейшего изучения
                stack.append(u)

    # Возвращаем список вершин текущей компоненты связности
    return comp


n, m = map(int, input().split())
# Инициализируем граф в виде словаря, где ключи - номера вершин, а значения - списки соседей
graph = {i: [] for i in range(1, n + 1)}

# Считываем m ребер и заполняем граф
for _ in range(m):
    u, v = map(int, input().split())
    # Добавляем ребро между вершинами u и v (двустороннее)
    graph[u].append(v)
    graph[v].append(u)

# Создаем список для отслеживания посещенных вершин (индекс 0 не используется)
visited = [False] * (n + 1)
# Список для хранения найденных компонент связности
components = []

# Ищем компоненты связности для каждой вершины
for i in range(1, n + 1):
    # Если вершина еще не посещена
    if not visited[i]:
        # Запускаем поиск в глубину для этой вершины
        component = dfs(i)
        # Добавляем найденную компоненту в общий список компонент
        components.append(component)

print(len(components))
# Для каждой компоненты выводим ее размер и отсортированные номера вершин
for component in components:
    print(len(component))
    print(*sorted(component))
