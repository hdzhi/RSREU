# Считываем количество вершин графа
n = int(input())
# Инициализируем матрицу смежности графа
matrix = []

for _ in range(n):
    matrix.append(list(map(int, input().split())))

# Массив для отслеживания состояния посещенных вершин
# 0 - не посещена, 1 - в процессе посещения (стек рекурсии), 2 - полностью посещена
visited = [0] * n
# Массив для отслеживания вершин в текущем стекe рекурсии (для обнаружения циклов)
recursion_stack = [False] * n


def dfs(u):
    # Отмечаем текущую вершину как посещенную и добавляем в стек рекурсии
    visited[u] = 1
    recursion_stack[u] = True

    # Проходим по всем вершинам графа (проверяем соседей)
    for v in range(n):
        if matrix[u][v] == 1:  # Если существует ребро от u к v
            if visited[v] == 0:  # Если v еще не посещена
                # Рекурсивно вызываем dfs для v
                if dfs(v):
                    return True  # Если цикл был найден в поддереве, возвращаем True
            elif recursion_stack[v]:  # Если v в текущем стеке рекурсии
                return True  # Мы нашли цикл

    # Убираем текущую вершину из стека рекурсии и помечаем как полностью посещенную
    recursion_stack[u] = False
    visited[u] = 2
    return False  # Возвращаем False, если нет цикла


cycle_found = False

# Проверяем каждую вершину
for i in range(n):
    if visited[i] == 0:  # Если вершина еще не посещена
        # Если dfs вернула True, значит, был найден цикл
        if dfs(i):
            cycle_found = True
            break  # Прерываем, так как мы уже нашли цикл

# Выводим 1, если цикл найден, и 0, если нет
print(1 if cycle_found else 0)
