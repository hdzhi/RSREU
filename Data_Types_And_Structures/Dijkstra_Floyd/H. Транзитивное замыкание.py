n = int(input())  # Считываем количество вершин в графе
graph = []  # Инициализация списка для хранения графа

# Считываем матрицу смежности графа
for _ in range(n):
    graph.append(list(map(int, input().split())))  # Добавляем строки графа в список

# Инициализация матрицы транзитивного замыкания
transitive = [[0] * n for _ in range(n)]  # Создаем n x n матрицу, заполненную нулями
for i in range(n):
    for j in range(n):
        transitive[i][j] = graph[i][j]  # Копируем значения из графа в матрицу транзитивного замыкания

# Устанавливаем длину путей равной 1 (если они есть)
for i in range(n):
    transitive[i][i] = 1  # Если вершина сама собой, то можно добраться, поэтому 1

# Алгоритм для нахождения транзитивного замыкания
for k in range(n):  # Перебираем все вершины как промежуточные
    for i in range(n):  # Для каждой начальной вершины
        for j in range(n):  # Для каждой конечной вершины
            # Проверяем, есть ли путь из i в j через промежуточную вершину k
            transitive[i][j] = transitive[i][j] or (transitive[i][k] and transitive[k][j])

# Выводим матрицу транзитивного замыкания
for row in transitive:
    print(*row)  # Печатаем каждую строку матрицы через пробел
