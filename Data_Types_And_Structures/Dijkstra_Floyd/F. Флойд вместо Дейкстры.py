import sys

def solve():
    line = sys.stdin.readline().split()  # Читаем строку из ввода и разбиваем её на части
    n = int(line[0])  # Количество вершин в графе
    s = int(line[1]) - 1  # Начальная вершина (уменьшаем на 1 для индексации с 0)
    t = int(line[2]) - 1  # Конечная вершина (уменьшаем на 1 для индексации с 0)

    graph = []  # Инициализация списка для хранения графа
    for _ in range(n):
        graph.append(list(map(int, sys.stdin.readline().split())))  # Читаем строки графа и добавляем их в список

    # Инициализация матрицы расстояний
    dist = [[float('inf')] * n for _ in range(n)]  # Создаем матрицу n x n, заполненную бесконечностями
    for i in range(n):
        dist[i][i] = 0  # Расстояние до самой себя равно 0
        for j in range(n):
            if graph[i][j] != -1:  # Если существует ребро между i и j
                dist[i][j] = graph[i][j]  # Устанавливаем расстояние между i и j в значении соответствующего ребра

    # Алгоритм Флойда-Уоршелла
    for k in range(n):  # Перебираем все вершины как промежуточные
        for i in range(n):  # Для каждой начальной вершины
            for j in range(n):  # Для каждой конечной вершины
                # Если путь через k короче, чем известный путь от i до j
                if dist[i][k] != float('inf') and dist[k][j] != float('inf') and dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]  # Обновляем короткий путь

    # Проверка на достижимость конечной вершины
    if dist[s][t] == float('inf'):
        print(-1)  # Если путь недостижим, выводим -1
    else:
        print(dist[s][t])  # Иначе выводим кратчайшее расстояние

solve()  # Вызов функции решения
