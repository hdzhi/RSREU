import heapq

def solve():
    n = int(input())  # Читаем количество узлов в графе
    start, end = map(int, input().split())  # Считываем начальную и конечную вершины
    r = int(input())  # Читаем количество рёбер

    edges = []  # Список для хранения рёбер
    for _ in range(r):  # Читаем рёбра графа
        u, d, v, arr = map(int, input().split())  # Считываем начало, время отправления, конец, время прибытия
        edges.append((u, d, v, arr))  # Добавляем рёбра в список

    # Создание графа в виде списков смежности
    graph = {i: [] for i in range(1, n + 1)}  # Инициализируем словарь для представления графа
    for u, d, v, arr in edges:  # Заполняем граф рёбрами
        graph[u].append((v, d, arr))  # Добавляем информацию о соседе с временем отправления и прибытия

    # Инициализация приоритетной очереди для поиска
    pq = [(0, start)]  # Начинаем с нулевого времени и начальной вершины
    visited = set()  # Множество для отслеживания посещённых вершин и времени

    while pq:  # Пока очередь не пуста
        time, c_node = heapq.heappop(pq)  # Извлекаем узел с наименьшим временем

        # Проверка, посещали ли уже этот узел в данный момент времени
        if (c_node, time) in visited:
            continue  # Если да, пропускаем

        visited.add((c_node, time))  # Добавляем текущую вершину и время в посещённые

        if c_node == end:  # Если достигли конечной вершины
            print(time)  # Выводим время достижения
            return  # Завершаем выполнение функции

        # Обходим всех соседей текущей вершины
        for neighbor, depart_time, arrive_time in graph.get(c_node, []):
            # Если текущее время меньше или равно времени отправления
            if time <= depart_time:
                heapq.heappush(pq, (arrive_time, neighbor))  # Добавляем соседа в очередь с временем прибытия

    print("-1")  # Если не удалось достичь конечной вершины, выводим -1

solve()  # Вызываем функцию решения
